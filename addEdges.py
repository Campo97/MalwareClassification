import sqlite3
import numpy as np
import sys
import networkx as nx
import pickle
import os

#Imposta flag e opzioni di default, come destinazione, grafo di input ecc ecc
flags = {}
inputs = {}
inputs['db_file'] = "database/datatest.db"
inputs['graph_file'] = "graphs/nodes"
inputs['dest_graph'] = "results/"


flags['TEST'] = False
flags['DOUBLECHECK'] = False
flags['GIVENGRAPH'] = False
flags['GIVENDATABASE'] = False
flags['GIVENDEST'] = False
flags['GIVENTHRESHOLD'] = False
flags['FORCECOMPUTE'] = True
flags['CONFIGEXISTS'] = False
flags['JUSTINITIALIZE'] = False
flags['ELIMINATEONCEDONE'] = False
flags['BOTH'] = False
flags['PRINTINFO'] = False
flags['SUBGRAPH'] = False
flags['FOUNDSTORE'] = False
flags['THRESHOLD'] = 0.97

# Lista dei possibli argomenti
possibleArgs = ['-h', '-dc', '--doublecheck', '-v', '--verbose', '--test', '-t',
                '-n', '--new', '-dest', '-g', '-db', '-i', '--init', '-r', '-c', '--cleanup', '--both', '-pi', '--sub']

# Classe dei nodi nel grafo, contiene il nome (codice hash) e la data estratta da VirusTotal
class Node:
    def __init__(self, name, date):
        self.name = name
        self.date = date

# Restituisce un nuovo grafo contenente i primi num nodi del grafo start
def subgraph(start, num):
    result = nx.DiGraph()
    result.add_nodes_from(list(start.nodes())[0:num])
    return result

# Restituisce il peso massimo degli archi nel grafo g e i nodi che quell'arco collega
def findMax(g):
    max = 0
    maxStart = ""
    maxEnd = ""
    for u, v, w in g.edges(data='weight'):
        if(w > max):
            maxStart = u.name
            maxEnd = v.name
            max = w
    return max, maxStart, maxEnd


# Restituisce il nodo con maggior archi entranti creando un dizionario di nodi, con valore il numero di archi entranti il nodo
# e restituendo l'elemento nel dizionario con valore maggiore
def maxInDeg(g):
    res = {}
    for n in g.nodes():
        res[n.name] = 0
    for u, v in g.edges():
        res[v.name] = res[v.name] + 1

    v = list(res.values())
    k = list(res.keys())
    return k[v.index(max(v))], max(v)

# Restituisce il nodo con maggior archi uscenti
def maxOutDeg(g):
    max = 0
    name = ""
    for n in g.nodes():
        if(g.degree(n) > max):
            name = n.name
            max = g.degree(n)
    return name, max

# Visualizza informazioni aggiuntive sul grafo g come numero di nodi e archi, i nodi più simili, il nodo con maggior archi uscenti o entranti
def printInfo(g):
    print("Il grafo contiene %d nodi e %d archi" % (len(g.nodes()), len(g.edges())))
    m, ms, me = findMax(g)
    print("Massima somiglianza tra " + ms +
          " e " + me + ": " + str(m) + "%")

    name, key = maxInDeg(g)
    print("Il nodo con più archi entranti è " +
          name + " con " + str(key) + " archi entranti")

    n, v = maxOutDeg(g)
    print("Il nodo con più archi uscenti è " + n +
          " con " + str(v) + " archi uscenti")

# Formatta il codice hash degli esemplari per eseguire query nel database
def getNameForDb(name):
    return 'VirusShare_' + name + '.o'

# Definisce se il nodo this è più recente o meno del nodo that
def isEarlier(this, that):
    yearThis, monthThis, dayThis = this.date.split(
        '-')[0], this.date.split('-')[1], this.date.split('-')[2]
    yearThat, monthThat, dayThat = that.date.split(
        '-')[0], that.date.split('-')[1], that.date.split('-')[2]

    if(yearThis < yearThat):
        return True

    elif(yearThis > yearThat):
        return False

    # stesso anno
    if(monthThis < monthThat):
        return True
    elif(monthThis > monthThat):
        return False

    # stesso mese
    if(dayThis < dayThat):
        return True
    elif(dayThis > dayThat):
        return False

    return False  # Restituisco False di default se i due nodi hanno la stessa data

# Esegue una query dal database per estrarre gli embedding del nodo node, formattandolo in un numpy array
def getEmbsFromNode(cursor, node):
    queryForEmbs = "select safe_embeddings from safe_embeddings s join functions f on s.id = f.id where file_name = '" + \
        getNameForDb(node.name) + "' and function_name like 'sub%'"
    cursor.execute(queryForEmbs)
    res = []
    for row in cursor.fetchall():
        emb = row[0]
        emb = emb.replace("[", "").replace("]", "")
        res.append(np.fromstring(emb, sep=' ', dtype=np.float64))
    return np.array(res)

# Computa la lista dei nodi più recenti del nodo start
def getToDo(start, nodes):
    to_do = []
    for n in nodes:
        if(isEarlier(start, n)):
            to_do.append(n)
    return to_do

# Controlla che ogni nodo nella lista sia effettivamente più recente di quello di partenza (test aggiuntivo)
def checkToDoList(node, list):
    for n in list:
        if(not isEarlier(node, n)):
            return False
    return True

# Stampa la lista dei possibli comandi dello script e termina l'esecuzione
def print_help_and_exit():
    print("Questo software è progettato per calcolare le somiglianze tra nodi di un grafo")
    print("E' necessario un database di embeddings, per ciascuna funzione di ciascun eseguibile, per il calcolo")
    print("Sarà creato un arco tra i nodi ritenuti simili oltre una certa soglia, con peso proporzionale alla somiglianza")

    print("Gli argomenti possibili sono:")
    print("\t -h ==> Stampa questa schermata e termina l'esecuzione")
    print("\t -dc --doublecheck ==> Esegue controlli opzionali in fase di preparazione")
    print("\t -v --verbose ==> Stampa informazioni aggiuntive durante l'esecuzione")
    print("\t -t <threshold> ==> Calcola le somiglianze usando la soglia data anzichè quella standard")
    print("\t -n --new ==> Forza la fase preparatoria ignorando eventuali dati precedenti")
    print("\t -g <path_to_graph_file> ==> Lavora sul grafo dato anzichè quello di default")
    print("\t -dest <path_to_graph_file> ==> Destinazione dove salvare il grafo risultante")
    print("\t -db <path_to_db_file> ==> Database da cui estrarre le informazioni anzichè quello di default")
    print("\t --both ==> Salva il risultato nei formati gpickle e graphml (di default solo graphml)")
    print("\t -i --init ==> Crea i file di background e termina l'esecuzione")
    print("\t -r ==> Rimuove i file di background e termina l'esecuzione")
    print("\t -c --cleanup ==> Rimuove i file di background una volta terminato")
    print("\t -pi ==> Stampa informazioni aggiuntive sul grafo risultante al termine dell'esecuzione")
    print("\t --sub <num> ==> Imposta come grafo di partenza il sottografo di num nodi del grafo di input")
    sys.exit()

# Elabora gli input dell'utente salvandoli nei dizionari globali precedentemente creati e lasciando le opzioni di default se non specificato diversamente
def computeArgs():
    # Sfrutta una computazione precedente se presente
    try:
        fh = open('.store.pckl', 'r')
        flags['CONFIGEXISTS'] = True
        flags['FORCECOMPUTE'] = False
        fh.close()
    except FileNotFoundError:
        flags['CONFIGEXISTS'] = False
        flags['FORCECOMPUTE'] = True

    args = sys.argv
    if(len(args) > 1):
        for elem in args:
            if(elem[0] == '-'):
                if(elem not in possibleArgs):
                    print("Opzione " + elem + " non riconosciuta")
                    print_help_and_exit()
                elif(elem == '-h'):
                    print_help_and_exit()
                elif(elem == '--test' or elem == '-v' or elem == '--verbose'):
                    flags['TEST'] = True
                elif(elem == '-dc' or elem == '--doublecheck'):
                    flags['DOUBLECHECK'] = True
                elif(elem == '-db'):
                    index = next(i for i in range(len(args))
                                 if args[i] == '-db') + 1
                    inputs['db_file'] = args[index]
                    flags['GIVENDATABASE'] = True
                elif(elem == '-g'):
                    index = next(i for i in range(len(args))
                                 if args[i] == '-g') + 1
                    inputs['graph_file'] = args[index]
                    flags['GIVENGRAPH'] = True
                elif(elem == '-dest'):
                    index = next(i for i in range(len(args))
                                 if args[i] == '-dest') + 1
                    inputs['dest_graph'] = args[index]
                    flags['GIVENDEST'] = True
                elif(elem == '-t'):
                    index = next(i for i in range(len(args))
                                 if args[i] == '-t') + 1
                    flags['THRESHOLD'] = float(args[index])
                    flags['GIVENTHRESHOLD'] = True
                elif(elem == '-n' or elem == '--new'):
                    flags['CONFIGEXISTS'] = False
                    flags['FORCECOMPUTE'] = True
                elif(elem == '-i' or elem == '--init'):
                    flags['JUSTINITIALIZE'] = True
                    flags['CONFIGEXISTS'] = False
                    flags['FORCECOMPUTE'] = True
                elif(elem == '-r'):
                    print("Rimuovo i file di background")
                    try:
                        os.remove(".store.pckl")
                    except FileNotFoundError:
                        print("File di Background assenti")
                        sys.exit()
                    print("Ok")
                    sys.exit()
                elif(elem == '-c' or elem == '--cleanup'):
                    flags['ELIMINATEONCEDONE'] = True
                elif(elem == '--both'):
                    flags['BOTH'] = True
                elif(elem == '-pi'):
                    flags['PRINTINFO'] = True
                elif(elem == '--sub'):
                    flags['SUBGRAPH'] = True
                    index = next(i for i in range(len(args))
                                 if args[i] == '--sub') + 1
                    inputs['numSubNodes'] = int(args[index])

# Stampa informazioni circa le opzioni utilizzate
def printInput():
    if(flags['TEST']):
        print("Esecuzione in modalità test, verranno stampate più informazioni del solito")
    if(flags['CONFIGEXISTS']):
        print("Utilizzo dati precedenti. Rieseguire con -n per forzare un nuovo calcolo")
    if(flags['DOUBLECHECK']):
        print("Verranno eseguiti controlli aggiuntivi in fase preparatoria")
    if(flags['GIVENDATABASE']):
        print("Verrà utilizzato il database " + inputs['db_file'])
    if(flags['GIVENGRAPH']):
        print("Verrà utilizzato il grafo " + inputs['graph_file'])
    if(flags['SUBGRAPH']):
        print("Verrà utilizzato il sottografo dei primi " + str(inputs['numSubNodes']) +
              " nodi del grafo di partenza")
    if(flags['GIVENDEST']):
        print("I risultati saranno salvati in " + inputs['dest_graph'])
    if(not flags['GIVENDEST']):
        print("I risultati saranno salvati secondo norme di default in results/")
    if(flags['GIVENTHRESHOLD']):
        print("Verrà utilizzata il valore di soglia di %f ", str(flags['THRESHOLD']))
    if(flags['JUSTINITIALIZE']):
        print("Verranno solo creati i file di background")
    if(flags['ELIMINATEONCEDONE']):
        print("I file di background saranno cancellati terminata l'esecuzione")
    if(flags['BOTH']):
        print("Il grafo risultante sarà salvato in entrambi i formati")
    if(flags['PRINTINFO']):
        print("Al termine dell'esecuzione saranno stampate informazioni aggiuntive sul grafo risultante")

# Calcola le liste di nodi e salva i risultati in background
# Se è presente una configugurazione precedente, carica quei dati senza ricalcolarli
def preparationPhase():
    if(flags['FORCECOMPUTE']):
        print("Fase Preparatoria")
        conn = sqlite3.connect(inputs['db_file'])
        cursor = conn.cursor()
        print("Database connesso")
        g = nx.read_gpickle(inputs['graph_file'] + ".gpickle")
        if(flags['SUBGRAPH']):
            g = subgraph(g, int(inputs['numSubNodes']))
        print("Caricato grafo di partenza")

        nodes = []
        for n in g.nodes():     #genera la lista di tutti i nodi del grafo
            nodes.append(n)

        num_nodes = len(nodes)
        print('%d nodi verranno analizzati' % num_nodes)

        print("Calcolo dei possibli nodi di destinazione")
        to_dos = []
        for n in nodes:  # Calcola la lista dei nodi di partenza per ogni nodo del grafo
            to_dos.append(getToDo(n, nodes))
        print("Ok")

        # liste da aggiornare durante la fase preparativa
        checkedNodes = []  # Lista dei nodi di partenza
        checkedToDos = []  # Lista dei nodi di arrivo per ogni nodo di partenza
        skipped = [] # Tutto il resto
        # Conta quanti nodi sono stati esclusi dalle liste perché non hanno embedding significativi
        skippedForNoEmbs = 0
        # Conta quanti nodi sono stati esclusi dalla lista di partenza perché non hanno nodi più recenti a cui compararli
        skippedForNoToDo = 0
        embDict = {}  # Dizionario degli embedding di ogni nodo, usa gli hash come chiavi e la lista di embeddings come valore

        print("Creazione liste preparatorie")
        for i in range(len(nodes)):
            if(flags['TEST']):
                print(str(i + 1) + "/" + str(num_nodes), end="\r")
            if(len(to_dos[i]) == 0):
                if(flags['TEST']):
                    print("Nodo " +
                          nodes[i].name + "eliminato dalla lista di partenza, non esistono nodi più recenti")
                skippedForNoToDo += 1
                skipped.append(nodes[i])
                continue
            if(flags['TEST']):
                print(str(len(to_dos[i])) + " nodi di destinazione da processare")

            # Interroga il database per gli embeddings del nodo nodes[i]
            embs = getEmbsFromNode(cursor, nodes[i])

            if(flags['TEST']):
                print(str(len(embs)) + " embeddings individuati")
            if(len(embs) == 0):
                if(flags['TEST']):
                    print("Nodo " +
                          nodes[i].name + " eliminato dalla lista di destinazione, non sono presenti embedding da controllare")
                skippedForNoEmbs += 1
                skipped.append(nodes[i])
                continue

            # Se il nodo non è stato escluso per qualche motivo, va aggiunto ai nodi della lista di partenza
            checkedNodes.append(nodes[i])
            # Se il nodo non è stato escluos per qualche motivo, ha una lista di nodi più recenti da analizzare
            checkedToDos.append(to_dos[i])
            embDict[nodes[i]] = embs    # Aggiorna il dizionario con gli embeddings
            # Assicura che embDict[i] si riferisca al nodo i con nodi di partenza to_dos[i]

        print("Tutti i nodi sono stati categorizzati")

        # Fase preparatoria completata, seguono stampe informative sui risultati ottenuti in caso di esecuzioni di test
        newLen = len(checkedNodes)
        if(flags['TEST']):
            print(str(len(embDict)) + " embedding salvati")
            print(str(newLen) + " nodi di partenza saranno trattati")
            print(str(len(checkedToDos)) + " liste di nodi di destinazione sono state generate")

        if(newLen != len(embDict)):  # La lista dei nodi di partenza non corrisponde con le chiavi del dizionario degli embedding
            cursor.close()
            conn.close()
            sys.exit("Embeddings e nodi di partenza non corrispondono, termino")

        # Le liste dei nodi di partenza e arrivo non coincidono
        if(newLen != len(checkedToDos)):
            cursor.close()
            conn.close()
            sys.exit("Le liste di nodi di partenza e arrivo non coincidono, termino")

        if(skippedForNoEmbs + skippedForNoToDo != 0): # Se qualcosa è stato escluso, si informa l'utente
            if(skippedForNoEmbs != 0):
                print(str(skippedForNoEmbs) +
                      " nodi sono stati eliminati perché privi di embeddings significativi")
            if(skippedForNoToDo != 0):
                print(str(skippedForNoToDo) +
                      " nodi sono stati eliminati perché non hanno nodi più recenti a cui compararli")
            print(str(newLen) + " nodi dei totali " +
                str(num_nodes) + " saranno effettivamente processati")

        else:
            print(str(num_nodes) + " nodi saranno processati")

        if(flags['DOUBLECHECK']):  # Ultimo test opzionale e più lento per assicurarsi che tutto sia corretto
            # controlla che ogni nodo di partenza ha una lista di arrivo e che tutti i nodi di arrivo siano più recenti del nodo di partenza
            print("Nodi di partenza e arrivo saranno controllati nuovamente")
            for i in range(len(checkedNodes)):
                if(not checkToDoList(checkedNodes[i], checkedToDos[i])):
                    cursor.close()
                    conn.close()
                    sys.exit("Nodi di partenza e arrivo non corrispondono, termino")
            print("Nessun problema rilevato")

        print("Sono stati calcolati " + str(len(embDict)) + " embeddings")

        # Il dizionario contiene tutti gli embeddings dei nodi di partenza ed è stato controllato. Bisogna ora aggiungerci tutti gli embedding dei nodi di arrivo così da non usare più il database
        for n in nodes:
            if(n not in embDict.keys()):
                embDict[n] = getEmbsFromNode(cursor, n)

        # Preparazione completata, rilascio risorse
        cursor.close()
        conn.close()
        print('Database disconnesso')
        print('Salvo i risultati per eventuali utilizzi futuri')
        # Salva tutto in un file di background per utilizzi futuri
        f = open('.store.pckl', 'wb')
        to_dump = [embDict, checkedNodes, checkedToDos, skipped]
        pickle.dump(to_dump, f)
        f.close()

        if(flags['JUSTINITIALIZE']):
            print("Tutti i file di background sono stati creati")
            sys.exit()
        print("Fase preparatoria completata")
        return embDict, checkedNodes, checkedToDos, skipped
    else:
        f = open('.store.pckl', 'rb')
        restored = pickle.load(f)
        embDict = restored[0]
        checkedNodes = restored[1]
        checkedToDos = restored[2]
        skipped = restored[3]
        f.close()
        return embDict, checkedNodes, checkedToDos, skipped

def computeSimilarities(embDict, checkedNodes, checkedToDos, skipped):
    index = 0
    edgesAdded = 0
    total = len(checkedNodes)
    g = nx.DiGraph()
    for startNode in checkedNodes:
        print("Analizzando: " + str(index + 1) + "/" + str(total), end="\r")
        g.add_node(startNode)       #Costruisco il grafo risultato, aggiungo il nodo di partenza
        totalToDo = str(len(checkedToDos[index]))
        if(flags['TEST']):
            print(startNode.name + ", " + totalToDo + " nodi da analizzare")
        toDoCount = 0
        # prendo gli embedding del nodo in esame di partenza
        startEmbs = embDict[startNode]
        # ciclo su tutti i nodi successivi al nodo di partenza
        for destNode in checkedToDos[index]:
            if(flags['TEST']):
                print(str(index + 1) + "/" + str(total) + ", analisi in corso di " +
                      str(toDoCount + 1) + "/" + totalToDo)
            g.add_node(destNode)    # Aggiungo il nodo destinazione
            destEmbs = embDict[destNode]
            count = 0
            base = len(startEmbs) * len(destEmbs)
            for emb1 in startEmbs:
                for emb2 in destEmbs:
                    res = np.dot(emb1, emb2)
                    if(res > float(flags['THRESHOLD'])):  # Ho trovato una similarità, creo un arco
                        count += 1
                        if(flags['TEST']):
                            print("Individuata similitudine: " + str(res))
            if(count > 0):
                w = (count / base) * 100  # Calcolo del peso dell'arco normalizzato e in percentuale
                edgesAdded += 1  # Conta quanti archi sono stati aggiunti al grafo
                g.add_edge(startNode, destNode, weight=w)  # Aggiungo l'arco al grafo risultato
            toDoCount += 1
        index += 1

    print("Ok")
    print(str(edgesAdded) + " nuovi archi sono stati aggiunti al grafo iniziale")
    for sk in skipped:  # Finito lo studio dei nodi da cui può partire o termiare un arco aggiungo tutti gli altri nodi isolati
        g.add_node(sk)
    return g

# Salva il grafo secondo le opzioni date in graphml (visualizzabile con gephi) o in gpickle (utlizzato dagli altri script)
def saveGraph(g):
    if(flags['GIVENDEST']):
        if(not flags['BOTH']):
            nx.write_graphml(g, inputs['dest_graph'] + '.graphml')
        else:
            nx.write_gpickle(g, inputs['dest_graph'] + '.gpickle')
            nx.write_graphml(g, inputs['dest_graph'] + '.graphml')
        print("Risultato salvato in " + inputs['dest_graph'])
    else:
        if(not flags['BOTH']):
            nx.write_graphml(g, 'results/edges' +
                             str(len(g.nodes())) + '.graphml')
        else:
            nx.write_gpickle(g, 'results/edges' +
                             str(len(g.nodes())) + '.gpickle')
            nx.write_graphml(g, 'results/edges' +
                             str(len(g.nodes())) + '.graphml')
        print("Risultato salvato in results/edges" +
                         str(len(g.nodes())))

# Esegue le ultime operazioni
def termination(g):
    if(flags['PRINTINFO']):
        printInfo(g)
    if(flags['ELIMINATEONCEDONE']):
        os.remove('.store.pckl')
        print("File di background rimossi")

def main():
    computeArgs()
    printInput()
    embDict, checkedNodes, checkedToDos, skipped = preparationPhase()
    graph = computeSimilarities(embDict, checkedNodes, checkedToDos, skipped)
    saveGraph(graph)
    termination(graph)
    print("Termino")
    sys.exit()

if __name__ == '__main__':
    main()
